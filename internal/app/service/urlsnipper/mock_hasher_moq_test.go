// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package urlsnipper

import (
	"sync"
)

// Ensure, that hasherMock does implement hasher.
// If this is not the case, regenerate this file with moq.
var _ hasher = &hasherMock{}

// hasherMock is a mock implementation of hasher.
//
//	func TestSomethingThatUseshasher(t *testing.T) {
//
//		// make and configure a mocked hasher
//		mockedhasher := &hasherMock{
//			HashFunc: func(s string) string {
//				panic("mock out the Hash method")
//			},
//		}
//
//		// use mockedhasher in code that requires hasher
//		// and then make assertions.
//
//	}
type hasherMock struct {
	// HashFunc mocks the Hash method.
	HashFunc func(s string) string

	// calls tracks calls to the methods.
	calls struct {
		// Hash holds details about calls to the Hash method.
		Hash []struct {
			// S is the s argument value.
			S string
		}
	}
	lockHash sync.RWMutex
}

// Hash calls HashFunc.
func (mock *hasherMock) Hash(s string) string {
	if mock.HashFunc == nil {
		panic("hasherMock.HashFunc: method is nil but hasher.Hash was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockHash.Lock()
	mock.calls.Hash = append(mock.calls.Hash, callInfo)
	mock.lockHash.Unlock()
	return mock.HashFunc(s)
}

// HashCalls gets all the calls that were made to Hash.
// Check the length with:
//
//	len(mockedhasher.HashCalls())
func (mock *hasherMock) HashCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockHash.RLock()
	calls = mock.calls.Hash
	mock.lockHash.RUnlock()
	return calls
}
